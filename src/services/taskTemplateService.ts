import { Task, Property } from '../types';
import { CONVENTIONAL_SELLER_TASKS, INVESTOR_SELLER_TASKS, TaskTemplate } from '../data/taskTemplates';

export class TaskTemplateService {
  private static instance: TaskTemplateService;

  private constructor() {}

  public static getInstance(): TaskTemplateService {
    if (!TaskTemplateService.instance) {
      TaskTemplateService.instance = new TaskTemplateService();
    }
    return TaskTemplateService.instance;
  }

  /**
   * Generate all tasks for a new property based on its workflow type
   */
  public generateTasksForProperty(property: Property): Task[] {
    const templates = this.getTemplatesForWorkflow(property.workflowType);
    const baseDate = new Date(property.createdAt);
    
    return templates.map((template, index) => {
      const dueDate = new Date(baseDate);
      dueDate.setDate(dueDate.getDate() + template.estimatedDays);
      
      return {
        id: `${property.id}_${template.id}`,
        title: template.title,
        description: template.description,
        dueDate: dueDate.toISOString().split('T')[0],
        priority: template.priority,
        status: 'Pending' as const,
        category: template.category,
        propertyId: property.id,
        taskType: this.mapCategoryToTaskType(template.category),
        isAutoGenerated: true,
        templateId: template.id,
        dependencies: template.dependencies?.map(depId => `${property.id}_${depId}`),
        requiredFor: template.requiredFor,
        order: index + 1
      };
    });
  }

  /**
   * Generate tasks for a specific stage (when property status changes)
   */
  public generateTasksForStage(property: Property, stage: 'Under Contract' | 'Pending' | 'Closed'): Task[] {
    const templates = this.getTemplatesForWorkflow(property.workflowType);
    const stageDate = new Date();
    
    let categoryFilter: string;
    switch (stage) {
      case 'Under Contract':
        categoryFilter = 'Under Contract';
        break;
      case 'Pending':
        categoryFilter = 'Closing Prep';
        break;
      default:
        return [];
    }

    const stageTemplates = templates.filter(t => t.category === categoryFilter);
    
    return stageTemplates.map((template, index) => {
      const dueDate = new Date(stageDate);
      dueDate.setDate(dueDate.getDate() + template.estimatedDays);
      
      return {
        id: `${property.id}_${template.id}_${Date.now()}`,
        title: template.title,
        description: template.description,
        dueDate: dueDate.toISOString().split('T')[0],
        priority: template.priority,
        status: 'Pending' as const,
        category: template.category,
        propertyId: property.id,
        taskType: this.mapCategoryToTaskType(template.category),
        isAutoGenerated: true,
        templateId: template.id,
        dependencies: template.dependencies?.map(depId => `${property.id}_${depId}`),
        requiredFor: template.requiredFor,
        order: index + 1
      };
    });
  }

  /**
   * Get task completion percentage for a property by category
   */
  public getCompletionStats(property: Property, tasks: Task[]): {
    listingPrep: { completed: number; total: number; percentage: number };
    underContract: { completed: number; total: number; percentage: number };
    closingPrep: { completed: number; total: number; percentage: number };
    overall: { completed: number; total: number; percentage: number };
  } {
    const propertyTasks = tasks.filter(t => t.propertyId === property.id && t.isAutoGenerated);
    
    const listingPrepTasks = propertyTasks.filter(t => t.category === 'Listing Prep');
    const underContractTasks = propertyTasks.filter(t => t.category === 'Under Contract');
    const closingPrepTasks = propertyTasks.filter(t => t.category === 'Closing Prep');
    
    const listingPrepCompleted = listingPrepTasks.filter(t => t.status === 'Completed').length;
    const underContractCompleted = underContractTasks.filter(t => t.status === 'Completed').length;
    const closingPrepCompleted = closingPrepTasks.filter(t => t.status === 'Completed').length;
    
    const totalCompleted = listingPrepCompleted + underContractCompleted + closingPrepCompleted;
    const totalTasks = propertyTasks.length;
    
    return {
      listingPrep: {
        completed: listingPrepCompleted,
        total: listingPrepTasks.length,
        percentage: listingPrepTasks.length ? Math.round((listingPrepCompleted / listingPrepTasks.length) * 100) : 0
      },
      underContract: {
        completed: underContractCompleted,
        total: underContractTasks.length,
        percentage: underContractTasks.length ? Math.round((underContractCompleted / underContractTasks.length) * 100) : 0
      },
      closingPrep: {
        completed: closingPrepCompleted,
        total: closingPrepTasks.length,
        percentage: closingPrepTasks.length ? Math.round((closingPrepCompleted / closingPrepTasks.length) * 100) : 0
      },
      overall: {
        completed: totalCompleted,
        total: totalTasks,
        percentage: totalTasks ? Math.round((totalCompleted / totalTasks) * 100) : 0
      }
    };
  }

  /**
   * Get next actionable tasks (no pending dependencies)
   */
  public getNextActionableTasks(property: Property, tasks: Task[]): Task[] {
    const propertyTasks = tasks.filter(t => t.propertyId === property.id && t.status === 'Pending');
    
    return propertyTasks.filter(task => {
      if (!task.dependencies || task.dependencies.length === 0) {
        return true; // No dependencies
      }
      
      // Check if all dependencies are completed
      return task.dependencies.every(depId => {
        const depTask = tasks.find(t => t.id === depId);
        return depTask?.status === 'Completed';
      });
    }).sort((a, b) => {
      // Sort by priority and order
      const priorityOrder = { 'Urgent': 4, 'High': 3, 'Medium': 2, 'Low': 1 };
      const priorityDiff = (priorityOrder[b.priority] || 0) - (priorityOrder[a.priority] || 0);
      if (priorityDiff !== 0) return priorityDiff;
      
      return (a.order || 0) - (b.order || 0);
    });
  }

  /**
   * Check if property is ready for status change based on required tasks
   */
  public canChangeStatus(property: Property, tasks: Task[], newStatus: 'Active' | 'Under Contract' | 'Pending' | 'Closed'): {
    canChange: boolean;
    blockers: Task[];
    message: string;
  } {
    const propertyTasks = tasks.filter(t => t.propertyId === property.id);
    
    let requiredMilestone: string | undefined;
    switch (newStatus) {
      case 'Active':
        requiredMilestone = 'MLS_LISTING';
        break;
      case 'Under Contract':
        requiredMilestone = 'CONTRACT';
        break;
      case 'Closed':
        requiredMilestone = 'CLOSING';
        break;
    }

    if (!requiredMilestone) {
      return { canChange: true, blockers: [], message: 'Status change allowed' };
    }

    const requiredTasks = propertyTasks.filter(t => t.requiredFor === requiredMilestone);
    const incompleteRequired = requiredTasks.filter(t => t.status !== 'Completed');

    if (incompleteRequired.length === 0) {
      return { canChange: true, blockers: [], message: 'All required tasks completed' };
    }

    return {
      canChange: false,
      blockers: incompleteRequired,
      message: `Cannot change to ${newStatus}. ${incompleteRequired.length} required tasks incomplete.`
    };
  }

  private getTemplatesForWorkflow(workflowType: 'Conventional' | 'Investor'): TaskTemplate[] {
    return workflowType === 'Conventional' ? CONVENTIONAL_SELLER_TASKS : INVESTOR_SELLER_TASKS;
  }

  private mapCategoryToTaskType(category: string): Task['taskType'] {
    switch (category) {
      case 'Listing Prep':
        return 'listing-prep';
      case 'Under Contract':
        return 'under-contract';
      case 'Closing Prep':
        return 'closing-prep';
      default:
        return 'custom';
    }
  }
}

export const taskTemplateService = TaskTemplateService.getInstance();